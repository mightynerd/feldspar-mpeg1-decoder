{-# LANGUAGE FlexibleContexts    #-}
{-# LANGUAGE ScopedTypeVariables #-}

module VLC.GenerateVLC where

import           System.IO
import           Lib.Data
import           Feldspar                hiding ( not )
import           Language.Embedded.Expression

import           Control.Monad.State.Lazy

files =
  [ "macroblock_address_increment"
  , "dct_dc_size_luminance"
  , "dct_dc_size_chrominance"
  , "motion_vector_codes"
  , "coded_block_pattern"
  ]

tup_files = ["dct_coeff_first", "dct_coeff_next"]

pent_files = ["macroblock_type_code_p", "macroblock_type_code_i"]

header =
  [ "-- Automatically generated by GenerateVLC.hs"
  , "module VLC.VLC where"
  , "import Lib.Data"
  , "import Feldspar"
  , ""
  ]

main :: IO ()
main = do
  vlcs      <- mapM (parseFile toTups . ("VLC/" ++)) files
  vlc_tups  <- mapM (parseFile toTrips . ("VLC/" ++)) tup_files
  vlc_pents <- mapM (parseFile toHexas . ("VLC/" ++)) pent_files
  handle    <- openFile "VLC/VLC.hs" WriteMode
  sequence_ [ hPutStrLn handle h | h <- header ]

  hPutStrLn handle " -- Single tables"
  sequence_
    [ hPutStrLn handle
      $  name
      ++ " :: VLC (Data Int32)\n"
      ++ name
      ++ " = "
      ++ vlc
      ++ "\n"
    | (name, vlc) <- zip files vlcs
    ]

  hPutStrLn handle ""
  hPutStrLn handle " -- Double tables"
  sequence_
    [ hPutStrLn handle
      $  name
      ++ " :: VLC (Data Int32, Data Int32)\n"
      ++ name
      ++ " = "
      ++ vlc
      ++ "\n"
    | (name, vlc) <- zip tup_files vlc_tups
    ]

  hPutStrLn handle ""
  hPutStrLn handle " -- Tables with five values"
  sequence_
    [ hPutStrLn handle
      $  name
      ++ " :: VLC (Data Int32, Data Int32, Data Int32, Data Int32, Data Int32)\n"
      ++ name
      ++ " = "
      ++ vlc
      ++ "\n"
    | (name, vlc) <- zip pent_files vlc_pents
    ]

parseFile
  :: forall a
   . (Read a, Show a)
  => (String -> (String, a))
  -> String
  -> IO String
parseFile parseLine file = do
  handle   <- openFile file ReadMode
  contents <- hGetContents handle
  let nodes :: [(String, a)]
      nodes =
        [ parseLine line | line <- filter (not . ignore) $ lines contents ]
  let parsed = parseList nodes
  return $ show parsed

ignore :: String -> Bool
ignore ('#' : s) = True
ignore ""        = True
ignore s         = False

toTups :: String -> (String, Data Int32)
toTups s | [s1, s2] <- words s = (s1, read s2)
         | otherwise           = error $ "Invalid input to toTups: " ++ s

toTrips :: String -> (String, (Data Int32, Data Int32))
toTrips s | [s1, s2, s3] <- words s = (s1, (read s2, read s3))
          | otherwise               = error $ "Invalid input to toTrips: " ++ s

toHexas
  :: String
  -> (String, (Data Int32, Data Int32, Data Int32, Data Int32, Data Int32))
toHexas s
  | [s1, s2, s3, s4, s5, s6] <- words s
  = (s1, (read s2, read s3, read s4, read s5, read s6))
  | otherwise
  = error $ "Invalid input to toHexas: " ++ s

insert :: (String, a) -> VLC a -> VLC a
insert (str, val) = insert' str (str, val) where
  insert' og (('1' : s), w) (Node i o) = Node (insert' og (s, w) i) o
  insert' og (('0' : s), w) (Node i o) = Node i (insert' og (s, w) o)
  insert' og (('1' : s), w) End        = Node (insert' og (s, w) End) End
  insert' og (('0' : s), w) End        = Node End (insert' og (s, w) End)
  insert' og (""       , w) End        = Leaf w
  insert' og (s, w) (Leaf _) =
    error
      $  "Invalid string "
      <> og
      <> ", overwriting leaf. Remaining string:"
      <> s
  insert' og ((c : s), w) _ =
    error $ "String " <> og <> " ended before reaching end node"

parseList :: Read a => [(String, a)] -> VLC a
parseList ts = execState (mapM (modify . insert) ts) End
